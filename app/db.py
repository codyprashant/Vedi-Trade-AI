from __future__ import annotations

import os
import json
from typing import Any, Dict, List, Optional, Tuple
import math

import psycopg2
from psycopg2.pool import SimpleConnectionPool
from psycopg2.extras import RealDictCursor, Json, execute_values
from dotenv import load_dotenv
from psycopg2 import sql as psql
from .config import (
    INDICATOR_PARAMS,
    WEIGHTS,
    SIGNAL_THRESHOLD,
    PRIMARY_TIMEFRAME,
    CONFIRMATION_TIMEFRAME,
    TREND_TIMEFRAME,
)


_pool: Optional[SimpleConnectionPool] = None


def get_pool() -> SimpleConnectionPool:
    global _pool
    if _pool is not None:
        return _pool

    # Load env variables from .env (if present)
    load_dotenv()

    user = os.getenv("user") or os.getenv("DB_USER")
    password = os.getenv("password") or os.getenv("DB_PASSWORD")
    host = os.getenv("host") or os.getenv("DB_HOST")
    port = os.getenv("port") or os.getenv("DB_PORT")
    dbname = os.getenv("dbname") or os.getenv("DB_NAME")

    if not all([user, password, host, port, dbname]):
        raise RuntimeError("Database credentials missing. Ensure .env has user, password, host, port, dbname")

    dsn = (
        f"user={user} password={password} host={host} port={port} dbname={dbname} sslmode=require connect_timeout=5"
    )
    _pool = SimpleConnectionPool(minconn=1, maxconn=5, dsn=dsn)
    return _pool


def _get_conn():
    pool = get_pool()
    return pool.getconn()


def _put_conn(conn):
    pool = get_pool()
    pool.putconn(conn)


def ensure_signals_table() -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    create table if not exists public.signals (
                      id bigint generated by default as identity primary key,
                      timestamp timestamptz not null,
                      symbol text not null,
                      timeframe text not null,
                      side text not null check (side in ('buy','sell')),
                      strength numeric not null,
                      strategy text not null,
                      indicators jsonb not null,
                      contributions jsonb not null,
                      indicator_contributions jsonb,
                      signal_type text,
                      primary_timeframe text,
                      confirmation_timeframe text,
                      trend_timeframe text,
                      h1_trend_direction text check (h1_trend_direction in ('Bullish','Bearish')),
                      h4_trend_direction text check (h4_trend_direction in ('Bullish','Bearish')),
                      alignment_boost numeric,
                      final_signal_strength numeric,
                      entry_price numeric,
                      stop_loss_price numeric,
                      take_profit_price numeric,
                      stop_loss_distance_pips numeric,
                      take_profit_distance_pips numeric,
                      risk_reward_ratio numeric,
                      volatility_state text,
                      is_valid boolean
                    );
                    """
                )
                # Ensure new columns exist
                cur.execute("alter table public.signals add column if not exists indicator_contributions jsonb")
                cur.execute("alter table public.signals add column if not exists signal_type text")
                cur.execute("alter table public.signals add column if not exists primary_timeframe text")
                cur.execute("alter table public.signals add column if not exists confirmation_timeframe text")
                cur.execute("alter table public.signals add column if not exists trend_timeframe text")
                cur.execute("alter table public.signals add column if not exists h1_trend_direction text")
                cur.execute("alter table public.signals add column if not exists h4_trend_direction text")
                cur.execute("alter table public.signals add column if not exists alignment_boost numeric")
                cur.execute("alter table public.signals add column if not exists final_signal_strength numeric")
                cur.execute("alter table public.signals add column if not exists entry_price numeric")
                cur.execute("alter table public.signals add column if not exists stop_loss_price numeric")
                cur.execute("alter table public.signals add column if not exists take_profit_price numeric")
                cur.execute("alter table public.signals add column if not exists stop_loss_distance_pips numeric")
                cur.execute("alter table public.signals add column if not exists take_profit_distance_pips numeric")
                cur.execute("alter table public.signals add column if not exists risk_reward_ratio numeric")
                cur.execute("alter table public.signals add column if not exists volatility_state text")
                cur.execute("alter table public.signals add column if not exists is_valid boolean")
    finally:
        _put_conn(conn)


def ensure_indicator_snapshots_table() -> None:
    """Create table to store periodic indicator analysis snapshots per symbol/timeframe."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    create table if not exists public.indicator_snapshots (
                      id bigint generated by default as identity primary key,
                      timestamp timestamptz not null,
                      symbol text not null,
                      timeframe text not null,
                      indicators jsonb not null,
                      evaluation jsonb,
                      strategy text,
                      created_at timestamptz default now()
                    );
                    """
                )
                # Idempotent column ensures
                cur.execute("alter table public.indicator_snapshots add column if not exists evaluation jsonb")
                cur.execute("alter table public.indicator_snapshots add column if not exists strategy text")
                cur.execute("alter table public.indicator_snapshots add column if not exists created_at timestamptz default now()")
    finally:
        _put_conn(conn)


def _sanitize_json(value: Any) -> Any:
    """Recursively replace NaN/Inf with None so data is valid JSON for Postgres.

    Handles primitives, dicts, lists/tuples. Leaves other types unchanged.
    """
    try:
        # Floats: convert NaN/Inf to None
        if isinstance(value, float):
            if math.isnan(value) or math.isinf(value):
                return None
            return value
        # Ints/bools/str/None are fine
        if isinstance(value, (int, bool, str)) or value is None:
            return value
        # Dict: sanitize values
        if isinstance(value, dict):
            return {k: _sanitize_json(v) for k, v in value.items()}
        # Lists/Tuples: sanitize items
        if isinstance(value, (list, tuple)):
            return [
                _sanitize_json(v) for v in value
            ]
    except Exception:
        # On any unexpected failure, return None to avoid invalid JSON
        return None
    return value


def ensure_backtesting_tables() -> None:
    """Create tables for manual backtesting runs and signals if they don't exist."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                # Signals generated during backtests
                cur.execute(
                    """
                    create table if not exists public.backtesting_signals (
                      id bigint generated by default as identity primary key,
                      manual_run_id text not null,
                      timestamp timestamptz not null,
                      symbol text not null,
                      signal_type text not null check (signal_type in ('BUY','SELL')),
                      entry_price numeric not null,
                      stop_loss_price numeric not null,
                      take_profit_price numeric not null,
                      final_signal_strength numeric not null,
                      volatility_state text,
                      risk_reward_ratio numeric,
                      indicator_contributions jsonb,
                      created_at timestamptz default now(),
                      source_mode text
                    );
                    """
                )
                # Ensure columns exist (idempotent alters)
                cur.execute("alter table public.backtesting_signals add column if not exists indicator_contributions jsonb")
                cur.execute("alter table public.backtesting_signals add column if not exists source_mode text")

                # Runs metadata table
                cur.execute(
                    """
                    create table if not exists public.backtesting_runs (
                      id bigint generated by default as identity primary key,
                      manual_run_id text unique not null,
                      start_date timestamptz not null,
                      end_date timestamptz not null,
                      symbol text not null,
                      timeframe text not null,
                      signals_generated integer default 0,
                      average_confidence numeric,
                      average_rr_ratio numeric,
                      run_duration_seconds numeric,
                      status text,
                      created_at timestamptz default now()
                    );
                    """
                )
                # Ensure new columns exist
                cur.execute("alter table public.backtesting_runs add column if not exists average_rr_ratio numeric")
                cur.execute("alter table public.backtesting_runs add column if not exists run_duration_seconds numeric")
                cur.execute("alter table public.backtesting_runs add column if not exists status text")
    finally:
        _put_conn(conn)


# --- Strategy configuration tables and helpers ---

def ensure_strategy_tables() -> None:
    """Create tables for strategies, indicator params, and weights if missing."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                # Strategies master table
                cur.execute(
                    """
                    create table if not exists public.strategies (
                      id bigint generated by default as identity primary key,
                      name text unique not null,
                      description text,
                      is_active boolean default false,
                      primary_timeframe text not null,
                      confirmation_timeframe text not null,
                      trend_timeframe text not null,
                      run_interval_seconds integer not null default 600,
                      signal_threshold numeric not null,
                      created_at timestamptz default now(),
                      updated_at timestamptz default now()
                    );
                    """
                )
                # Indicator configs per strategy
                cur.execute(
                    """
                    create table if not exists public.strategy_indicators (
                      id bigint generated by default as identity primary key,
                      strategy_id bigint not null references public.strategies(id) on delete cascade,
                      indicator_name text not null,
                      params jsonb not null,
                      unique (strategy_id, indicator_name)
                    );
                    """
                )
                # Weights per strategy (stored as jsonb for simplicity)
                cur.execute(
                    """
                    create table if not exists public.strategy_weights (
                      id bigint generated by default as identity primary key,
                      strategy_id bigint not null references public.strategies(id) on delete cascade,
                      weights jsonb not null,
                      unique (strategy_id)
                    );
                    """
                )
    finally:
        _put_conn(conn)


def create_default_gold_strategy_if_missing() -> None:
    """Seed a default 'Gold Strategy' using current static defaults if missing."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute("select id from public.strategies where name = %s", ("Gold Strategy",))
                row = cur.fetchone()
                if row:
                    return
                # Insert strategy
                cur.execute(
                    """
                    insert into public.strategies (
                      name, description, is_active, primary_timeframe, confirmation_timeframe, trend_timeframe,
                      run_interval_seconds, signal_threshold
                    ) values (%s,%s,%s,%s,%s,%s,%s,%s) returning id
                    """,
                    (
                        "Gold Strategy",
                        "Default strategy for XAUUSD with technical indicators and MTF validation",
                        True,
                        PRIMARY_TIMEFRAME,
                        CONFIRMATION_TIMEFRAME,
                        TREND_TIMEFRAME,
                        600,
                        50.0,
                    ),
                )
                strategy_id = cur.fetchone()[0]

                # Insert indicator params
                for name, params in INDICATOR_PARAMS.items():
                    cur.execute(
                        """
                        insert into public.strategy_indicators (strategy_id, indicator_name, params)
                        values (%s, %s, %s)
                        """,
                        (strategy_id, name, Json(params)),
                    )

                # Insert weights
                cur.execute(
                    """
                    insert into public.strategy_weights (strategy_id, weights)
                    values (%s, %s)
                    """,
                    (strategy_id, Json(WEIGHTS)),
                )
    finally:
        _put_conn(conn)


def get_strategies() -> List[Dict[str, Any]]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    """
                    select id, name, description, is_active, primary_timeframe, confirmation_timeframe, trend_timeframe,
                           run_interval_seconds, signal_threshold, created_at, updated_at
                    from public.strategies order by id asc
                    """
                )
                rows = cur.fetchall()
                return [dict(r) for r in rows]
    finally:
        _put_conn(conn)


def get_strategy_details(strategy_id: int) -> Dict[str, Any]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    "select id, name, description, is_active, primary_timeframe, confirmation_timeframe, trend_timeframe, run_interval_seconds, signal_threshold from public.strategies where id = %s",
                    (strategy_id,),
                )
                s = cur.fetchone()
                if not s:
                    raise RuntimeError("Strategy not found")
                cur.execute(
                    "select indicator_name, params from public.strategy_indicators where strategy_id = %s",
                    (strategy_id,),
                )
                inds = cur.fetchall()
                cur.execute(
                    "select weights from public.strategy_weights where strategy_id = %s",
                    (strategy_id,),
                )
                w = cur.fetchone()
                # Build indicator params robustly for both dict and tuple rows
                indicator_params: Dict[str, Any] = {}
                for row in inds:
                    if isinstance(row, dict):
                        name = row.get("indicator_name")
                        params = row.get("params")
                    else:
                        try:
                            name, params = row[0], row[1]
                        except Exception:
                            name, params = None, None
                    if name is not None:
                        indicator_params[name] = params

                # Extract weights robustly
                weights_val: Dict[str, Any] = {}
                if w:
                    if isinstance(w, dict):
                        weights_val = w.get("weights") or {}
                    else:
                        try:
                            weights_val = w[0] if w[0] else {}
                        except Exception:
                            weights_val = {}

                return {
                    **dict(s),
                    "indicator_params": indicator_params,
                    "weights": weights_val,
                }
    finally:
        _put_conn(conn)


def get_active_strategy_config() -> Dict[str, Any]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute("select id from public.strategies where is_active = true limit 1")
                row = cur.fetchone()
                if not row:
                    # No active strategy; create default and return it
                    create_default_gold_strategy_if_missing()
                    cur.execute("select id from public.strategies where is_active = true limit 1")
                    row = cur.fetchone()
                strategy_id = int(row["id"])
                return get_strategy_details(strategy_id)
    finally:
        _put_conn(conn)


def update_indicator_params(strategy_id: int, indicator_name: str, params: Dict[str, Any]) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    insert into public.strategy_indicators (strategy_id, indicator_name, params)
                    values (%s,%s,%s)
                    on conflict (strategy_id, indicator_name) do update set params = excluded.params
                    """,
                    (strategy_id, indicator_name, Json(params)),
                )
    finally:
        _put_conn(conn)


def update_strategy_weights(strategy_id: int, weights: Dict[str, Any]) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    insert into public.strategy_weights (strategy_id, weights)
                    values (%s,%s)
                    on conflict (strategy_id) do update set weights = excluded.weights
                    """,
                    (strategy_id, Json(weights)),
                )
    finally:
        _put_conn(conn)


def update_strategy_schedule(strategy_id: int, run_interval_seconds: int) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    "update public.strategies set run_interval_seconds = %s, updated_at = now() where id = %s",
                    (int(run_interval_seconds), int(strategy_id)),
                )
    finally:
        _put_conn(conn)


def update_strategy_threshold(strategy_id: int, signal_threshold: float) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    "update public.strategies set signal_threshold = %s, updated_at = now() where id = %s",
                    (float(signal_threshold), int(strategy_id)),
                )
    finally:
        _put_conn(conn)


def set_active_strategy(strategy_id: int) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                # Deactivate all, activate one
                cur.execute("update public.strategies set is_active = false")
                cur.execute("update public.strategies set is_active = true where id = %s", (int(strategy_id),))
    finally:
        _put_conn(conn)


def insert_signal(record: Dict[str, Any]) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    insert into public.signals (
                        timestamp, symbol, timeframe, side, strength, strategy, indicators, contributions,
                        indicator_contributions, signal_type,
                        primary_timeframe, confirmation_timeframe, trend_timeframe,
                        h1_trend_direction, h4_trend_direction, alignment_boost, final_signal_strength,
                        entry_price, stop_loss_price, take_profit_price,
                        stop_loss_distance_pips, take_profit_distance_pips,
                        risk_reward_ratio, volatility_state, is_valid
                    ) values (
                        %s,%s,%s,%s,%s,%s,%s,%s,
                        %s,%s,
                        %s,%s,%s,
                        %s,%s,%s,%s,
                        %s,%s,%s,
                        %s,%s,
                        %s,%s,%s
                    )
                    """,
                    (
                        record["timestamp"],
                        record["symbol"],
                        record["timeframe"],
                        record["side"],
                        record["strength"],
                        record["strategy"],
                        Json(_sanitize_json(record["indicators"])),
                        Json(_sanitize_json(record["contributions"])),
                        Json(_sanitize_json(record.get("indicator_contributions"))),
                        record.get("signal_type"),
                        record.get("primary_timeframe"),
                        record.get("confirmation_timeframe"),
                        record.get("trend_timeframe"),
                        record.get("h1_trend_direction"),
                        record.get("h4_trend_direction"),
                        record.get("alignment_boost"),
                        record.get("final_signal_strength"),
                        record.get("entry_price"),
                        record.get("stop_loss_price"),
                        record.get("take_profit_price"),
                        record.get("stop_loss_distance_pips"),
                        record.get("take_profit_distance_pips"),
                        record.get("risk_reward_ratio"),
                        record.get("volatility_state"),
                        record.get("is_valid"),
                    ),
                )
    finally:
        _put_conn(conn)


def insert_indicator_snapshot(record: Dict[str, Any]) -> None:
    """Insert a single indicator analysis snapshot."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    insert into public.indicator_snapshots (
                        timestamp, symbol, timeframe, indicators, evaluation, strategy
                    ) values (%s,%s,%s,%s,%s,%s)
                    """,
                    (
                        record["timestamp"],
                        record["symbol"],
                        record["timeframe"],
                        Json(_sanitize_json(record["indicators"])),
                        Json(_sanitize_json(record.get("evaluation"))),
                        record.get("strategy"),
                    ),
                )
    finally:
        _put_conn(conn)


def fetch_latest_indicator_snapshots(symbols: list[str] | None = None) -> list[dict[str, Any]]:
    """Return the latest snapshot per symbol; optionally filter by provided symbols."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                if symbols:
                    cur.execute(
                        """
                        select distinct on (symbol)
                          symbol, timestamp, timeframe, indicators, evaluation, strategy
                        from public.indicator_snapshots
                        where symbol = any(%s)
                        order by symbol, timestamp desc
                        """,
                        (symbols,),
                    )
                else:
                    cur.execute(
                        """
                        select distinct on (symbol)
                          symbol, timestamp, timeframe, indicators, evaluation, strategy
                        from public.indicator_snapshots
                        order by symbol, timestamp desc
                        """,
                    )
                rows = cur.fetchall()
                out = []
                for r in rows:
                    out.append(
                        {
                            "symbol": r[0],
                            "timestamp": r[1],
                            "timeframe": r[2],
                            "indicators": r[3],
                            "evaluation": r[4],
                            "strategy": r[5],
                        }
                    )
                return out
    finally:
        _put_conn(conn)


def fetch_recent_signals(limit: int = 20) -> List[Dict[str, Any]]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    "select * from public.signals order by timestamp desc limit %s",
                    (limit,),
                )
                rows = cur.fetchall()
                return [dict(row) for row in rows]
    finally:
        _put_conn(conn)


def fetch_recent_signals_by_symbol(symbol: str, limit: int = 5) -> List[Dict[str, Any]]:
    """Return the most recent signals for a given symbol."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    "select * from public.signals where symbol = %s order by timestamp desc limit %s",
                    (symbol, limit),
                )
                rows = cur.fetchall()
                return [dict(row) for row in rows]
    finally:
        _put_conn(conn)


def fetch_latest_signal_by_symbol(symbol: str) -> Optional[Dict[str, Any]]:
    """Return the latest signal row for a given symbol, or None."""
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    "select * from public.signals where symbol = %s order by timestamp desc limit 1",
                    (symbol,),
                )
                row = cur.fetchone()
                return dict(row) if row else None
    finally:
        _put_conn(conn)


def insert_backtesting_signals_batch(records: List[Dict[str, Any]]) -> None:
    """Batch insert backtesting signals for a manual run."""
    if not records:
        return
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cols = (
                    "manual_run_id",
                    "timestamp",
                    "symbol",
                    "signal_type",
                    "entry_price",
                    "stop_loss_price",
                    "take_profit_price",
                    "final_signal_strength",
                    "volatility_state",
                    "risk_reward_ratio",
                    "indicator_contributions",
                    "created_at",
                    "source_mode",
                )
                values = [
                    (
                        r["manual_run_id"],
                        r["timestamp"],
                        r["symbol"],
                        r["signal_type"],
                        r["entry_price"],
                        r["stop_loss_price"],
                        r["take_profit_price"],
                        r["final_signal_strength"],
                        r.get("volatility_state"),
                        r.get("risk_reward_ratio"),
                        Json(r.get("indicator_contributions")),
                        r.get("created_at"),
                        r.get("source_mode"),
                    )
                    for r in records
                ]
                sql = f"insert into public.backtesting_signals ({', '.join(cols)}) values %s"
                execute_values(cur, sql, values)
    finally:
        _put_conn(conn)


def insert_backtesting_run(meta: Dict[str, Any]) -> None:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    insert into public.backtesting_runs (
                      manual_run_id, start_date, end_date, symbol, timeframe,
                      signals_generated, average_confidence, average_rr_ratio,
                      run_duration_seconds, status, created_at
                    ) values (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
                    on conflict (manual_run_id) do update set
                      signals_generated = excluded.signals_generated,
                      average_confidence = excluded.average_confidence,
                      average_rr_ratio = excluded.average_rr_ratio,
                      run_duration_seconds = excluded.run_duration_seconds,
                      status = excluded.status
                    """,
                    (
                        meta["manual_run_id"],
                        meta["start_date"],
                        meta["end_date"],
                        meta["symbol"],
                        meta["timeframe"],
                        meta.get("signals_generated", 0),
                        meta.get("average_confidence"),
                        meta.get("average_rr_ratio"),
                        meta.get("run_duration_seconds"),
                        meta.get("status", "completed"),
                        meta.get("created_at"),
                    ),
                )
    finally:
        _put_conn(conn)


def fetch_backtesting_runs(
    from_date: Optional[str] = None,
    to_date: Optional[str] = None,
    min_signal_strength: Optional[float] = None,
    symbol: Optional[str] = None,
) -> List[Dict[str, Any]]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                base = "select manual_run_id, start_date, end_date, symbol, timeframe, signals_generated, average_confidence, average_rr_ratio from public.backtesting_runs"
                clauses: List[str] = []
                params: List[Any] = []
                if from_date:
                    clauses.append("start_date >= %s")
                    params.append(from_date)
                if to_date:
                    clauses.append("end_date <= %s")
                    params.append(to_date)
                if symbol:
                    clauses.append("symbol = %s")
                    params.append(symbol)
                sql = base + (" where " + " and ".join(clauses) if clauses else "") + " order by created_at desc"
                cur.execute(sql, tuple(params))
                rows = cur.fetchall()
                # min_signal_strength filter requires join/aggregation; approximate using signals table when provided
                results = [dict(r) for r in rows]
                if min_signal_strength is not None:
                    # Filter runs by existence of at least one signal meeting threshold
                    filtered: List[Dict[str, Any]] = []
                    for r in results:
                        cur.execute(
                            "select count(*) from public.backtesting_signals where manual_run_id = %s and final_signal_strength >= %s",
                            (r["manual_run_id"], min_signal_strength),
                        )
                        cnt = cur.fetchone()[0]
                        if cnt > 0:
                            filtered.append(r)
                    results = filtered
                return results
    finally:
        _put_conn(conn)


def fetch_backtesting_signals_by_run(manual_run_id: str) -> List[Dict[str, Any]]:
    conn = _get_conn()
    try:
        with conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    """
                    select manual_run_id, timestamp, symbol, signal_type,
                           entry_price, stop_loss_price, take_profit_price,
                           final_signal_strength, volatility_state, risk_reward_ratio,
                           indicator_contributions
                    from public.backtesting_signals
                    where manual_run_id = %s
                    order by timestamp asc
                    """,
                    (manual_run_id,),
                )
                rows = cur.fetchall()
                return [dict(r) for r in rows]
    finally:
        _put_conn(conn)